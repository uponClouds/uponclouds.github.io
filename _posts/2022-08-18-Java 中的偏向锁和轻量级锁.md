---
layout: post
title: Java 中的偏向锁和轻量级锁
categories: Java
---

在为了减少获得锁和释放锁带来的性能消耗，在 Java SE 1.6 中开始引入了 “偏向锁” 和 “轻量级锁” ，此时锁一共有四种状态，从低到高分别是：**无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态**，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。

## 锁状态

当某个线程要访问某个对象时，是如何判断该对象是否有锁的呢？这就需要检查对象的对象头了。 HotSpot 虚拟机的对象头（Object Header）分为两部分，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等。这部分数据的长度在32位和64位的 Java 虚拟机中分别会占用32个或64个比特，官方称它为 `Mark Word`。这部分是实现轻量级锁和偏向锁的关键。另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。

在无锁状态时，JVM(32位)的 `Mark Word` 默认储存结构如下图所示：![](https://blogimg-1253107768.cos.ap-guangzhou.myqcloud.com/blogImage/20220815191128.png)

在运行期间，`Mark Word` 里的数据会随着锁标志位的变化而变化：![](https://blogimg-1253107768.cos.ap-guangzhou.myqcloud.com/blogImage/20220815191327.png)

## 偏向锁

引入偏向锁的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。因为在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

### 偏向锁的获得

假设当前虚拟机启用了偏向锁（启用参数`-XX：+UseBiased Locking`，这是自JDK 6起HotSpot虚拟机的默认值），当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行`CAS`操作来加锁和解锁，只需简单地测试一下对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下`Mark Word`中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用`CAS`竞争锁；如果设置了，则尝试使用`CAS`将对象头的偏向锁指向当前线程。

> 当对象进入偏向状态的时候，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，在Java语言里面一个对象如果计算过哈希码，就应该一直保持该值不变（对象通过Object::hashCode()方法，将计算结果保存在对象头中）。因此，当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求 [1] 时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。

### 偏向锁的撤销

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的`Mark Word`要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。



## 轻量级锁

轻量级锁是JDK 6时加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就被称为“重量级”锁。不过，需要强调一点，轻量级锁并不是用来代替重量级锁的，它设计的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

### 轻量级锁的加锁

在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word），这时候线程堆栈与对象头的状态如图所示：![](https://blogimg-1253107768.cos.ap-guangzhou.myqcloud.com/blogImage/20221007224727.png)

然后，虚拟机将使用`CAS`操作尝试把对象的`Mark Word`更新为指向`Lock Record`的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象`Mark Word`的锁标志位（`Mark Word`的最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如图所示：![](https://blogimg-1253107768.cos.ap-guangzhou.myqcloud.com/blogImage/20221007224820.png)

如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的`Mark Word`是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时`Mark Word`中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。

### 轻量级锁的解锁

它的解锁过程也同样是通过`CAS`操作来进行的，如果对象的`Mark Word`仍然指向线程的锁记录，那就用`CAS`操作把对象当前的`Mark Word`和线程中复制的`Displaced Mark Word`替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。

> 轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。



## 总结

| 锁       | 优点                                                         | 缺点                                           | 适用场景                           |
| -------- | ------------------------------------------------------------ | ---------------------------------------------- | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景   |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到锁竞争的线程，使用自旋会消耗 CPU | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 | 线程竞争不适用自旋，不会消耗 CPU                             | 线程阻塞，响应时间缓慢                         | 追求吞吐量，同步块执行速度较长     |



## 参考

[1] 方腾飞,魏鹏,程晓明. “Java并发编程的艺术 (Java核心技术系列)。” Apple Books. 

[2] 周志明. “深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）。” Apple Books. 